#!/usr/bin/python

import sys, os, subprocess
from os import path
import shutil
import re
import tempfile
import atexit
import urllib2
import argparse
import yaml
from zipfile import ZipFile

quiet = 0

def sanitize_path(dir_name, name, where):
    if re.search(r'[^/\w.-]', name):
        raise ValueError, "unsanitary path in %s"%(where)
    full_name = path.normpath(path.join(dir_name, name))
    if full_name.find(dir_name + os.sep) != 0:
        raise ValueError, "unsafe path in %s"%(where)

def remove_temp(tdir):
    shutil.rmtree(tdir)

def download(url, dest):
    file_name = url.split('/')[-1]
    u = urllib2.urlopen(url)
    f = open(dest, 'w')
    meta = u.info()
    file_size = int(meta.getheaders("Content-Length")[0])
    if quiet == 0:
        print "Downloading: %s Bytes: %s" % (file_name, file_size)

    file_size_dl = 0
    block_sz = 65536
    while True:
        buffer = u.read(block_sz)
        if not buffer:
            break

        file_size_dl += block_sz
        f.write(buffer)
        status = r"%10d  [%3.2f%%]" % (file_size_dl, file_size_dl * 100. / file_size)
        status = status + chr(8)*(len(status)+1)
        if quiet == 0:
            print status,

    if quiet == 0:
        print
    f.close()

def extract(dir_name, zip_path):
    zipfile = ZipFile(zip_path, 'r')
    files = []
    for name in zipfile.namelist():
        sanitize_path(dir_name, name, "zip file")
    zipfile.extractall(dir_name)
    zipfile.close()

    for name in zipfile.namelist():
        if path.isfile(path.join(dir_name, name)):
            files.append(path.normpath(name))
    return files

def get_assertions(temp_dir, unpack_dir, file_names):
    assertions = {"build" : {}}
    sums = {}
    to_check = {}
    for file_name in file_names:
        shasum = subprocess.Popen(["sha256sum", '-b', os.path.join(unpack_dir, file_name)], stdout=subprocess.PIPE).communicate()[0][0:64]
        sums[file_name] = shasum
        to_check[file_name] = 1

    out_manifest = False
    error = False

    for file_name in file_names:
        if file_name.startswith("gitian"):
            del to_check[file_name]
            if file_name.endswith(".assert"):
                popen = subprocess.Popen(["gpg", '--homedir', path.join(temp_dir, 'gpg'), '--keyid-format', 'long', '--quiet', '--batch', '--verify', os.path.join(unpack_dir, file_name + '.pgp'), os.path.join(unpack_dir, file_name)], stderr=subprocess.PIPE)
                gpgout = popen.communicate()[1]
                retcode = popen.wait()
                if retcode != 0:
                    if quiet <= 1:
                        print>>sys.stderr, 'PGP verify failed for %s' %(file_name)
                    error = True
                    continue
                match = re.search(r'key ([A-F0-9]+)$', gpgout, re.M)
                assertions['build'][match.group(1)] = 1
                f = file(os.path.join(unpack_dir, file_name), 'r')
                assertion = yaml.load(f, OrderedDictYAMLLoader)
                f.close()
                if assertion['out_manifest']:
                    if out_manifest:
                        if out_manifest != assertion['out_manifest']:
                            print>>sys.stderr, 'not all out manifests are identical'
                            error = True
                            continue
                    else:
                        out_manifest = assertion['out_manifest']

    if out_manifest:
        for line in out_manifest.split("\n"):
            if line != "":
                shasum = line[0:64]
                summed_file = line[66:]
                if sums[summed_file] != shasum:
                    print>>sys.stderr, "sha256sum mismatch on %s" %(summed_file)
                    error = True
                del to_check[summed_file]
        if len(to_check) > 0 and quiet == 0:
            print>>sys.stderr, "Some of the files were not checksummed:"
            for key in to_check:
                print>>sys.stderr, "  ", key
    else:
        print>>sys.stderr, 'No build assertions found'
        error = True

    return (not error, assertions, sums)

def import_keys(temp_dir, config):
    os.mkdir(path.join(temp_dir, 'gpg'), 0700)
    signers = config['signers']
    for keyid in signers:
        popen = subprocess.Popen(["gpg", '--homedir', path.join(temp_dir, 'gpg'), '--import', '--quiet', '--batch'], stdin=subprocess.PIPE)
        popen.communicate(signers[keyid]['key'])
        if popen.wait() != 0:
            print>>sys.stderr, 'Key %s failed to import'%(keyid)

def check_assertions(config, assertions):
    total_weight = 0
    signers = config['signers']
    if quiet == 0:
        print 'Signatures from:'
    for key in assertions['build']:
        if not signers.has_key(key):
            if quiet <= 1:
                print>>sys.stderr, 'key %s is not in config, skipping'%(key)
            continue
        if quiet == 0:
            print '    %s : weight %d'%(signers[key]['name'], signers[key]['weight'])
        total_weight += signers[key]['weight']
    if total_weight < config['minimum_weight']:
        print>>sys.stderr, "The total weight of signatures is %d, which is less than the minimum required %d"%(total_weight, config['minimum_weight'])
        return False
    return total_weight


class OrderedDictYAMLLoader(yaml.Loader):
    """
    A YAML loader that loads ordered yaml maps into a dictionary.
    """

    def __init__(self, *args, **kwargs):
        yaml.Loader.__init__(self, *args, **kwargs)

        self.add_constructor(u'!omap', type(self).construct_yaml_map)

    def construct_yaml_map(self, node):
        data = dict()
        yield data
        for mapping in node.value:
            for key, value in mapping.value:
                key = self.construct_object(key)
                value = self.construct_object(value)
                data[key] = value

full_prog = sys.argv[0]

prog = os.path.basename(full_prog)

parser = argparse.ArgumentParser(description='Download a verify a gitian package')
parser.add_argument('-u', '--url', metavar='URL', type=str, nargs='+', required=True,
                   help='one or more URLs where the package can be found')
parser.add_argument('-c', '--config', metavar='CONF', type=str, required=True,
                   help='a configuration file')
parser.add_argument('-d', '--dest', metavar='DEST', type=str, required=True,
                   help='the destination directory for unpacking')
parser.add_argument('-q', '--quiet', action='append_const', const=1, default=[], help='be quiet')

args = parser.parse_args()

url = args.url[0]
config_file = args.config
quiet = len(args.quiet)

f = file(config_file, 'r')
config = yaml.safe_load(f)
f.close()

if path.exists(args.dest):
    print>>sys.stderr, "destination already exists, please remove it first"
    exit(1)

temp_dir = tempfile.mkdtemp('', prog)

atexit.register(remove_temp, temp_dir)

import_keys(temp_dir, config)

package_file = path.join(temp_dir, 'package')
download(url, package_file)

unpack_dir = path.join(temp_dir, 'unpack')
files = extract(unpack_dir, package_file)
(success, assertions, out_manifest) = get_assertions(temp_dir, unpack_dir, files)
if not success and quiet <= 1:
    print>>sys.stderr, "There were errors getting assertions"

total_weight = check_assertions(config, assertions)
if not total_weight:
    print>>sys.stderr, "There were errors checking assertions, build is untrusted, aborting"
    exit(1)

if quiet == 0:
    print>>sys.stderr, "Successful with signature weight %d"%(total_weight)

shutil.copytree(unpack_dir, args.dest)
f = file(path.join(args.dest, '.manifest'), 'w')
yaml.dump(out_manifest, f)
f.close()

#os.system("cd %s ; /bin/bash"%(temp_dir))
